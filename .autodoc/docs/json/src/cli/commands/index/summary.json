{
  "folderName": "index",
  "folderPath": ".autodoc\\docs\\json\\src\\cli\\commands\\index",
  "url": "https://github.com/context-labs/autodoc/.autodoc\\docs\\json\\src\\cli\\commands\\index",
  "files": [
    {
      "fileName": "convertJsonToMarkdown.ts",
      "filePath": "src\\cli\\commands\\index\\convertJsonToMarkdown.ts",
      "url": "https://github.com/context-labs/autodoc/src\\cli\\commands\\index\\convertJsonToMarkdown.ts",
      "summary": "The `convertJsonToMarkdown` function in this code is responsible for converting JSON files containing documentation information into Markdown files. This function is part of the larger Autodoc project, which aims to automate the process of generating documentation for code repositories.\n\nThe function takes an `AutodocRepoConfig` object as input, which contains various configuration options such as the project name, input and output directories, and other settings related to the documentation generation process.\n\nThe code first counts the number of files in the project by traversing the file system using the `traverseFileSystem` utility function. This is done to provide a progress update to the user via the `updateSpinnerText` function.\n\nNext, the `processFile` function is defined, which is responsible for reading the content of each JSON file, parsing it, and converting it into a Markdown format. The function checks if the file has a summary, and if so, it generates the Markdown content with a link to the code on GitHub, the summary, and any questions if present. The output Markdown file is then saved in the specified output directory.\n\nFinally, the `traverseFileSystem` function is called again, this time with the `processFile` function as an argument. This allows the code to process each JSON file in the project and convert it into a Markdown file. Once the process is complete, a success message is displayed to the user using the `spinnerSuccess` function.\n\nExample usage:\n\n```javascript\nconvertJsonToMarkdown({\n  name: \"myProject\",\n  root: \"./input\",\n  output: \"./output\",\n  filePrompt: true,\n  folderPrompt: true,\n  contentType: \"code\",\n  targetAudience: \"developers\",\n  linkHosted: \"https://github.com/user/myProject\",\n});\n```\n\nThis will convert all JSON files in the `./input` directory into Markdown files and save them in the `./output` directory.",
      "questions": "1. **Question:** What is the purpose of the `convertJsonToMarkdown` function and what are the expected inputs?\n   **Answer:** The `convertJsonToMarkdown` function is used to convert JSON files to Markdown files for each code file in the project. It takes an `AutodocRepoConfig` object as input, which contains various properties like projectName, root, output, filePrompt, folderPrompt, contentType, targetAudience, and linkHosted.\n\n2. **Question:** How does the `traverseFileSystem` function work and what is its role in this code?\n   **Answer:** The `traverseFileSystem` function is a utility function that recursively traverses the file system, starting from the inputPath, and processes each file using the provided `processFile` function. In this code, it is used twice: first to count the number of files in the project, and then to create Markdown files for each code file in the project.\n\n3. **Question:** How are the output directories and Markdown files created, and what is the structure of the generated Markdown content?\n   **Answer:** The output directories are created using the `fs.mkdir` function with the `recursive: true` option. The Markdown files are created using the `fs.writeFile` function. The structure of the generated Markdown content includes a link to view the code on GitHub, the summary, and optionally, a list of questions if they exist.",
      "checksum": "79c860becf47b9882441682f0213d534"
    },
    {
      "fileName": "createVectorStore.ts",
      "filePath": "src\\cli\\commands\\index\\createVectorStore.ts",
      "url": "https://github.com/context-labs/autodoc/src\\cli\\commands\\index\\createVectorStore.ts",
      "summary": "The code in this file is responsible for processing a directory of text files, splitting the text into chunks, and creating a vector store using the HNSWLib library and OpenAIEmbeddings. This vector store can be used for efficient similarity search and retrieval of documents in the larger project.\n\nThe `processFile` function reads a file's content and creates a `Document` object with the content and metadata (source file path). It returns a Promise that resolves to the created Document.\n\nThe `processDirectory` function is a recursive function that processes a directory and its subdirectories. It reads the files in the directory, and for each file, it checks if it's a directory or a regular file. If it's a directory, the function calls itself with the new directory path. If it's a file, it calls the `processFile` function to create a Document object. The function returns an array of Document objects.\n\nThe `RepoLoader` class extends the `BaseDocumentLoader` class and has a constructor that takes a file path as an argument. It has a `load` method that calls the `processDirectory` function with the given file path and returns the array of Document objects.\n\nThe `createVectorStore` function is an async function that takes an `AutodocRepoConfig` object as an argument, which contains the root directory and output file path. It creates a `RepoLoader` instance with the root directory and loads the documents using the `load` method. It then creates a `RecursiveCharacterTextSplitter` instance with a specified chunk size and chunk overlap and splits the documents into chunks. Finally, it creates a vector store using the HNSWLib library and OpenAIEmbeddings with the processed documents and saves the vector store to the output file path.\n\nExample usage:\n\n```javascript\nconst config = {\n  root: './data/documents',\n  output: './data/vector_store',\n};\n\ncreateVectorStore(config).then(() => {\n  console.log('Vector store created successfully');\n});\n```",
      "questions": "1. **Question:** What is the purpose of the `processFile` function and what does it return?\n   **Answer:** The `processFile` function is an asynchronous function that reads the content of a file given its file path, creates a `Document` object with the file contents and metadata (source file path), and returns a Promise that resolves to the created `Document` object.\n\n2. **Question:** How does the `processDirectory` function work and what does it return?\n   **Answer:** The `processDirectory` function is an asynchronous function that takes a directory path as input, reads all the files and subdirectories within it, and processes them recursively. It returns a Promise that resolves to an array of `Document` objects created from the files in the directory and its subdirectories.\n\n3. **Question:** What is the purpose of the `createVectorStore` function and how does it work?\n   **Answer:** The `createVectorStore` function is an asynchronous function that takes an `AutodocRepoConfig` object as input, which contains the root directory path and output file path. The function loads all the documents from the root directory using the `RepoLoader`, splits the text into chunks using the `RecursiveCharacterTextSplitter`, creates a vector store from the documents using the `HNSWLib` and `OpenAIEmbeddings`, and saves the vector store to the specified output file.",
      "checksum": "a3409c4340753a867c72eebef7626fb9"
    },
    {
      "fileName": "index.ts",
      "filePath": "src\\cli\\commands\\index\\index.ts",
      "url": "https://github.com/context-labs/autodoc/src\\cli\\commands\\index\\index.ts",
      "summary": "The code in this file is responsible for processing a given repository and generating documentation in JSON, Markdown, and vector formats. It exports a single function `index` that takes an `AutodocRepoConfig` object as its argument, which contains various configuration options for processing the repository.\n\nThe `index` function performs three main tasks:\n\n1. **Process the repository**: It traverses the repository, calls the LLMS (Language Learning Management System) for each file, and creates JSON files with the results. This is done using the `processRepository` function, which takes the same configuration options as the `index` function. The JSON files are stored in the `output/docs/json/` directory.\n\n   ```javascript\n   updateSpinnerText('Processing repository...');\n   await processRepository({ /* configuration options */ });\n   spinnerSuccess();\n   ```\n\n2. **Create Markdown files**: It converts the generated JSON files into Markdown files using the `convertJsonToMarkdown` function. This function also takes the same configuration options as the `index` function. The Markdown files are stored in the `output/docs/markdown/` directory.\n\n   ```javascript\n   updateSpinnerText('Creating markdown files...');\n   await convertJsonToMarkdown({ /* configuration options */ });\n   spinnerSuccess();\n   ```\n\n3. **Create vector files**: It creates vector files from the generated Markdown files using the `createVectorStore` function. This function also takes the same configuration options as the `index` function. The vector files are stored in the `output/docs/data/` directory.\n\n   ```javascript\n   updateSpinnerText('Create vector files...');\n   await createVectorStore({ /* configuration options */ });\n   spinnerSuccess();\n   ```\n\nThroughout the execution of these tasks, the code uses `updateSpinnerText` and `spinnerSuccess` functions to provide visual feedback on the progress of the tasks.\n\nIn the larger project, this code would be used to automatically generate documentation for a given repository based on the provided configuration options. The generated documentation can then be used for various purposes, such as displaying it on a website or analyzing the content for specific insights.",
      "questions": "1. **What does the `index` function do in this code?**\n\n   The `index` function is the main entry point for the autodoc project. It takes an `AutodocRepoConfig` object as input and performs three main tasks: processing the repository and creating JSON files, converting JSON files to markdown files, and creating vector files.\n\n2. **What is the purpose of the `processRepository`, `convertJsonToMarkdown`, and `createVectorStore` functions?**\n\n   The `processRepository` function traverses the repository, calls LLMS for each file, and creates JSON files with the results. The `convertJsonToMarkdown` function creates markdown files from the generated JSON files. The `createVectorStore` function creates vector files from the markdown files.\n\n3. **What are the different types of prompts (`filePrompt`, `folderPrompt`, `chatPrompt`) used for in this code?**\n\n   These prompts are likely used to interact with the user during the processing of the repository. The `filePrompt` might be used to ask the user for input regarding specific files, the `folderPrompt` for input regarding folders, and the `chatPrompt` for general input or feedback during the processing.",
      "checksum": "4060b1affae5a6c385cda308b3cd1750"
    },
    {
      "fileName": "processRepository.ts",
      "filePath": "src\\cli\\commands\\index\\processRepository.ts",
      "url": "https://github.com/context-labs/autodoc/src\\cli\\commands\\index\\processRepository.ts",
      "summary": "The `processRepository` function in this code is responsible for generating summaries and questions for code files and folders in a given repository. It takes an `AutodocRepoConfig` object as input, which contains information about the project, repository URL, input and output paths, language models, and other configurations. An optional `dryRun` parameter can be provided to skip actual API calls and file writing.\n\nThe function starts by initializing the encoding and rate limit for API calls. It then defines two main helper functions: `processFile` and `processFolder`. The `processFile` function is responsible for processing individual code files. It reads the file content, calculates a checksum, and checks if reindexing is needed. If reindexing is required, it creates prompts for summaries and questions, selects the appropriate language model based on the input length, and calls the language model API to generate the summaries and questions. The results are then saved to a JSON file in the output directory.\n\nThe `processFolder` function is responsible for processing folders. It reads the folder content, calculates a checksum, and checks if reindexing is needed. If reindexing is required, it reads the summaries and questions of all files and subfolders in the folder, calls the language model API to generate a summary for the folder, and saves the result to a `summary.json` file in the folder.\n\nThe main function then counts the number of files and folders in the project and processes them using the `traverseFileSystem` utility function. It processes all files first, followed by all folders. Finally, it returns the language model usage statistics.\n\nThe `calculateChecksum` function calculates the checksum of a list of file contents, while the `reindexCheck` function checks if reindexing is needed by comparing the new and old checksums of a file or folder.",
      "questions": "1. **Question:** What is the purpose of the `processRepository` function and what are its inputs and outputs?\n   **Answer:** The `processRepository` function processes a given code repository, generating summaries and questions for each file and folder within the repository. It takes an `AutodocRepoConfig` object and an optional `dryRun` boolean as inputs. The function returns a `Promise` that resolves to an object containing the models used during processing.\n\n2. **Question:** How does the `calculateChecksum` function work and what is its purpose?\n   **Answer:** The `calculateChecksum` function takes an array of file contents as input and calculates a checksum for each file using the MD5 hashing algorithm. It then concatenates all the checksums and calculates a final checksum using MD5 again. The purpose of this function is to generate a unique identifier for the contents of the files, which can be used to determine if the files have changed and need to be reprocessed.\n\n3. **Question:** How does the `reindexCheck` function work and when is it used?\n   **Answer:** The `reindexCheck` function checks if a summary.json file exists in the given file or folder path and compares the stored checksum with the new checksum to determine if the file or folder needs to be reindexed. It is used in the `processFile` and `processFolder` functions to decide whether to regenerate summaries and questions for a file or folder based on changes in their contents.",
      "checksum": "5b3ae9ffad1d4b4a22c6f7fd66bbde6f"
    },
    {
      "fileName": "prompts.ts",
      "filePath": "src\\cli\\commands\\index\\prompts.ts",
      "url": "https://github.com/context-labs/autodoc/src\\cli\\commands\\index\\prompts.ts",
      "summary": "This code defines three utility functions that generate prompts for documentation experts working on a project. These functions are used to create documentation for code files and folders within a project. The generated prompts are in markdown format and include specific instructions for the documentation expert.\n\n1. `createCodeFileSummary`: This function generates a prompt for creating a summary of a code file. It takes five parameters: `filePath`, `projectName`, `fileContents`, `contentType`, and `filePrompt`. The function returns a markdown formatted string that includes the file's content and a custom prompt for the documentation expert.\n\nExample usage:\n```javascript\nconst prompt = createCodeFileSummary('path/to/file.js', 'MyProject', 'const x = 10;', 'JavaScript', 'Write a detailed technical explanation of this code.');\n```\n\n2. `createCodeQuestions`: This function generates a prompt for creating a list of questions and answers about a code file. It takes five parameters: `filePath`, `projectName`, `fileContents`, `contentType`, and `targetAudience`. The function returns a markdown formatted string that includes the file's content and a custom prompt for the documentation expert to provide questions and answers.\n\nExample usage:\n```javascript\nconst prompt = createCodeQuestions('path/to/file.js', 'MyProject', 'const x = 10;', 'JavaScript', 'beginner');\n```\n\n3. `folderSummaryPrompt`: This function generates a prompt for creating a summary of a folder containing code files and subfolders. It takes six parameters: `folderPath`, `projectName`, `files`, `folders`, `contentType`, and `folderPrompt`. The `files` parameter is an array of `FileSummary` objects, and the `folders` parameter is an array of `FolderSummary` objects. The function returns a markdown formatted string that includes a list of files and folders with their summaries and a custom prompt for the documentation expert.\n\nExample usage:\n```javascript\nconst prompt = folderSummaryPrompt('path/to/folder', 'MyProject', fileSummaries, folderSummaries, 'JavaScript', 'Write a detailed technical explanation of this folder structure.');\n```\n\nThese functions can be used in the larger project to generate documentation tasks for experts, ensuring consistent formatting and instructions across different parts of the project.",
      "questions": "1. **What is the purpose of the `createCodeFileSummary` function?**\n\n   The `createCodeFileSummary` function generates a string template for a code file summary prompt, which includes the file path, project name, file contents, content type, and a file prompt.\n\n2. **How does the `createCodeQuestions` function differ from the `createCodeFileSummary` function?**\n\n   The `createCodeQuestions` function generates a string template for a code documentation prompt that asks for 3 questions and their answers, while the `createCodeFileSummary` function generates a string template for a code file summary prompt.\n\n3. **What is the role of the `folderSummaryPrompt` function?**\n\n   The `folderSummaryPrompt` function generates a string template for a folder summary prompt, which includes the folder path, project name, lists of files and folders with their summaries, content type, and a folder prompt.",
      "checksum": "e44b82bf4912be69149685a997b6bde3"
    }
  ],
  "folders": [],
  "summary": "The code in this folder is responsible for processing a given repository and generating documentation in JSON, Markdown, and vector formats. It consists of several functions and utilities that work together to automate the documentation generation process.\n\nThe main function, `index`, takes an `AutodocRepoConfig` object as input, which contains various configuration options for processing the repository. It performs three main tasks:\n\n1. **Process the repository**: It calls the `processRepository` function to traverse the repository, generate summaries and questions for code files and folders using the LLMS (Language Learning Management System), and create JSON files with the results. These JSON files are stored in the `output/docs/json/` directory.\n\n2. **Create Markdown files**: It uses the `convertJsonToMarkdown` function to convert the generated JSON files into Markdown files. These Markdown files are stored in the `output/docs/markdown/` directory.\n\n3. **Create vector files**: It calls the `createVectorStore` function to create vector files from the generated Markdown files. These vector files are stored in the `output/docs/data/` directory.\n\nThroughout the execution of these tasks, the code provides visual feedback on the progress of the tasks using `updateSpinnerText` and `spinnerSuccess` functions.\n\nHere's an example of how this code might be used:\n\n```javascript\nindex({\n  name: \"myProject\",\n  root: \"./input\",\n  output: \"./output\",\n  filePrompt: true,\n  folderPrompt: true,\n  contentType: \"code\",\n  targetAudience: \"developers\",\n  linkHosted: \"https://github.com/user/myProject\",\n});\n```\n\nThis will process the repository located at `./input`, generate documentation in JSON, Markdown, and vector formats, and save the results in the `./output` directory.\n\nThe `prompts.ts` file contains utility functions that generate prompts for documentation experts. These functions create markdown formatted strings with specific instructions for the documentation expert, ensuring consistent formatting and instructions across different parts of the project.\n\nIn summary, the code in this folder automates the process of generating documentation for a given repository based on the provided configuration options. The generated documentation can be used for various purposes, such as displaying it on a website or analyzing the content for specific insights.",
  "questions": "",
  "checksum": "376f96417f8cbea6a5ab2463268fe4af"
}